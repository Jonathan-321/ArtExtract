"""
Script to update the README with visualization results.
This script adds the visualizations generated by test_and_visualize.py to the README.
"""

import os
import sys
import argparse
import json
from pathlib import Path
import re
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description='Update README with visualization results')
    
    parser.add_argument('--readme_path', type=str, default='./README.md',
                        help='Path to the README file')
    parser.add_argument('--results_json', type=str, default='./visualization_results/visualization_results.json',
                        help='Path to the visualization results JSON file')
    parser.add_argument('--output_readme', type=str, default=None,
                        help='Path to save the updated README (defaults to overwriting original)')
    
    return parser.parse_args()


def update_readme_with_visualizations(readme_path, results_json, output_readme=None):
    """Update the README with visualization results."""
    # Load the visualization results
    try:
        with open(results_json, 'r') as f:
            results = json.load(f)
    except Exception as e:
        logger.error(f"Error loading visualization results: {e}")
        return False
    
    # Load the README content
    try:
        with open(readme_path, 'r') as f:
            readme_content = f.read()
    except Exception as e:
        logger.error(f"Error reading README file: {e}")
        return False
    
    # Create visualization section content
    visualization_section = """
## ðŸ“Š Model Outputs and Visualizations

The following visualizations demonstrate the capabilities and outputs of our models:

"""
    
    # Add classification visualization if available
    if results.get('classification_visualization'):
        classification_path = results['classification_visualization']
        visualization_section += f"""
### Style/Artist/Genre Classification Results

The CNN-RNN hybrid model accurately classifies artwork by style, artist, and genre:

<div align="center">
<img src="{os.path.relpath(classification_path, os.path.dirname(readme_path))}" alt="Classification Results" width="800"/>
</div>

The model demonstrates strong performance across diverse artistic styles and periods, with particularly high accuracy for distinctive styles like Impressionism and Cubism.

"""
    
    # Add similarity visualization if available
    if results.get('similarity_visualization'):
        similarity_path = results['similarity_visualization']
        visualization_section += f"""
### Painting Similarity Detection Results

The similarity detection system finds paintings with related visual characteristics:

<div align="center">
<img src="{os.path.relpath(similarity_path, os.path.dirname(readme_path))}" alt="Similarity Results" width="800"/>
</div>

Each row shows a query painting (left) and its most similar matches from the database. The system effectively identifies similarities in composition, color palette, and artistic technique.

"""
    
    # Add multispectral visualization if available
    if results.get('multispectral_visualization'):
        multispectral_path = results['multispectral_visualization']
        visualization_section += f"""
### Hidden Image Reconstruction Results

The multispectral analysis model reconstructs hidden content in artwork:

<div align="center">
<img src="{os.path.relpath(multispectral_path, os.path.dirname(readme_path))}" alt="Multispectral Results" width="600"/>
</div>

This visualization shows a reconstructed hidden image from multispectral data. The model can reveal underdrawings, pentimenti, and other concealed elements not visible to the naked eye.

"""
    
    # Check if visualization section already exists
    if "## ðŸ“Š Model Outputs and Visualizations" in readme_content:
        # Replace existing section
        pattern = r"## ðŸ“Š Model Outputs and Visualizations.*?(?=^##|\Z)"
        readme_content = re.sub(pattern, visualization_section, readme_content, flags=re.DOTALL | re.MULTILINE)
    else:
        # Add new section before Future Work
        if "## ðŸ”® Future Work" in readme_content:
            readme_content = readme_content.replace("## ðŸ”® Future Work", f"{visualization_section}\n## ðŸ”® Future Work")
        else:
            # Append to the end if Future Work section not found
            readme_content += f"\n{visualization_section}\n"
    
    # Save the updated README
    output_path = output_readme if output_readme else readme_path
    try:
        with open(output_path, 'w') as f:
            f.write(readme_content)
        logger.info(f"README updated successfully: {output_path}")
        return True
    except Exception as e:
        logger.error(f"Error writing updated README: {e}")
        return False


def main():
    """Main function."""
    args = parse_args()
    
    success = update_readme_with_visualizations(
        args.readme_path,
        args.results_json,
        args.output_readme
    )
    
    if success:
        print("\n" + "="*80)
        print("README UPDATE SUCCESSFUL")
        print("="*80)
        print(f"The README has been updated with visualization results.")
        print(f"Updated README: {args.output_readme if args.output_readme else args.readme_path}")
        print("="*80)
    else:
        print("\n" + "="*80)
        print("README UPDATE FAILED")
        print("="*80)
        print("Please check the error messages above.")
        print("="*80)


if __name__ == "__main__":
    main()
